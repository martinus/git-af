#!/usr/bin/env python3

"""
git-af - Git Autofixup

TODO

"""

__version_info__ = ('0', '0', '1')
__version__ = '.'.join(__version_info__)

import argparse
from collections import defaultdict
import re
import subprocess
from dataclasses import dataclass
from typing import List, Tuple
from pprint import pprint


@dataclass
class Hunk:
    file: str
    start_line: int
    num_lines: int
    header: str
    lines: List[str]
    # For each line of the hunk, this is the sha of the commit (with resolved fixups)
    blame: List[str]


@dataclass
class ShaSummary:
    sha: str
    summary: str


class GitAutoFixup:
    def __init__(self, args):
        self._args = args

    def _is_index_dirty(self):
        """
        checks whether the Git index (staging area) has any changes that are not yet committed.
        True when anything is staged, false otherwise.
        """
        result = subprocess.run(
            ["git", "diff-index", "--cached", "HEAD", "--quiet"],
            cwd=self._toplevel, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        return result.returncode

    def _parse_diff_filename(self, line) -> str:
        filename = line[4:].strip('\t\n')
        if filename:
            filename = re.sub(r'^[abiwco]/', '', filename)
        return filename

    def _parse_hunks(self, stream):
        """
        parses git diff format into hunks
        """
        hunks = []
        file_a = ""
        file_b = ""
        line = None
        has_next_line = False

        while True:
            if not has_next_line:
                line = stream.readline().rstrip('\t\n')
            has_next_line = False
            if not line:
                break

            if line.startswith('--- '):
                file_a = self._parse_diff_filename(line)
            elif line.startswith('+++ '):
                file_b = self._parse_diff_filename(line)
            elif file_a == file_b:
                # Ignore creations and deletions when they are not equal
                match = re.match(
                    r'^@@ -(\d+)(?:,(\d+))? \+\d+(?:,\d+)? @@', line)
                if match:
                    header = line
                    lines = []
                    has_next_line = True
                    while True:
                        line = stream.readline().rstrip('\t\n')
                        if not line or not re.match(r'^[ +\\-]', line):
                            break
                        lines.append(line)
                    hunk = Hunk(file_a, int(match.group(1)),
                                int(match.group(2)), header, lines, [])
                    hunks.append(hunk)
        return hunks

    def _diff_hunks(self):
        """
        Returns the diff hunks for the repository. If the index is dirty, the hunks will include cached changes.
        """

        cmd = ["git", "-c", "diff.noprefix=false", "diff", "--no-ext-diff",
               "--ignore-submodules", f"-U{self._args.unified}"]
        if self._is_index_dirty():
            cmd.append("--cached")

        proc = subprocess.Popen(cmd, cwd=self._toplevel,
                                encoding='utf-8', stdout=subprocess.PIPE)
        return self._parse_hunks(proc.stdout)

    def _summary_for_commits(self, rev: str) -> dict[str, str]:
        """
        Returns an array [(sha, commit message summary), (sha, msg), ...] of all the commits that can be used
        for fixup commits
        """
        commits = {}
        for line in subprocess.check_output(['git', 'log', '--no-merges', f'--format=%H:%s', f'{rev}..']).decode().split('\n'):
            line = line.strip()
            if not line:
                continue
            sha, summary = line.split(':', maxsplit=1)
            commits[sha] = summary
        return commits

    def _collect_sha_with_prefix(self, summary_for: dict[str, str], prefix: str) -> List[str]:
        sha_list = []
        for sha, summary in summary_for.items():
            if summary.startswith(prefix):
                sha_list.append(sha)
        return sha_list

    def _sha_aliases(self, summary_for: dict[str, str]) -> dict[str, str]:
        """
        Returns a dictionary of SHA-1 aliases for fixup!/squash! commits.

        The function takes a dictionary `summary_for` that maps each commit's SHA-1 hash to
        its summary message. It then searches for commits with a summary message starting
        with "fixup!" or "squash!", and generates an alias for each commit that points to
        the SHA-1 hash of the commit being fixed up or squashed. The function returns a
        dictionary that maps each fixup!/squash! commit SHA-1 hash to its alias.

        Example usage:
        ```python
        summaries = summary_for_commits('HEAD')
        aliases = sha_aliases(summaries)
        for sha, alias in aliases.items():
            print(f'{sha} -> {alias}')
        ```
        """

        # count number of commits for each commit
        summary_to_count = defaultdict(int)
        for sha, summary in summary_for.items():
            summary_to_count[summary] += 1
        
        pprint(summary_to_count)


        aliases = {}
        for sha, summary in summary_for.items():
            match = re.match(r"^(?:fixup|squash)! (.*)", summary)
            if not match:
                continue

            prefix = match.group(1)
            if re.match(r"^(?:fixup|squash)! ", prefix):
                print(
                    "ERROR: fixup commits for fixup commits are not supported: {sha}")
                exit(1)

            # find commit target for fixup
            matches = self._collect_sha_with_prefix(summary_for, prefix)
            if len(matches) > 1:
                print(
                    "ERROR: ambiguous fixup commit target: multiple commit summaries start with '{prefix}'")
                exit(1)
            if len(matches) == 0:
                print(
                    "ERROR: could not find a fixup target for {sha}")
                exit(1)

            # got it!
            aliases[sha] = matches[0]
        return aliases

    def _blame(self, hunk: Hunk, alias_for: dict[str, str]) -> Hunk:
        """
        Blame for the hunk, collect the SHA hash of each line.
        Uses alias_for to resolve the fixup SHAs.
        """
        with subprocess.Popen(["git", "blame", "--porcelain", f"-L {hunk.start_line},+{hunk.num_lines}", "HEAD", "--", hunk.file],
                              cwd=self._toplevel, encoding='utf-8', stdout=subprocess.PIPE) as proc:
            sha = str
            expected_line_number = hunk.start_line
            current_line_number = str
            for line in proc.stdout:
                # Parse the SHA and line number from the current line if possible
                match = re.match(r'^([0-9a-f]{40}) \d+ (\d+)', line)
                if match:
                    sha, current_line_number = match.groups()
                elif line.startswith('\t'):
                    if expected_line_number != int(current_line_number):
                        print(
                            f"ERROR: blame expected line number {expected_line_number} but got {current_line_number}!")
                        exit(1)
                    expected_line_number += 1
                    # look up aliases, or use the original value if not found.
                    hunk.blame.append(alias_for.get(sha, sha))
        return hunk
    
    def _fixup_hunk_by_sha(self, hunk: Hunk, summary_for: List[ShaSummary]) :
        targets = list(set(hunk.blame))

        pprint(hunk.blame)
        pprint(targets)
        pprint("----")

    def process(self):
        print(self._args)

        # sanity checks
        result = subprocess.run(["git", "rev-parse", "--verify", self._args.upstream + '^{commit}'],
                                stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        if result.returncode != 0:
            print(
                f'ERROR: cannot resolve the given commit "{self._args.upstream}"')
            exit(2)

        if self._args.unified < 0:
            print(
                f'ERROR: context line needs to be >= 0, got {self._args.unified}')
            exit(1)

        # find out git's root directory
        self._toplevel = subprocess.check_output(
            ["git", "rev-parse", "--show-toplevel"], encoding='utf-8').strip()

        hunks = self._diff_hunks()
        summary_for = self._summary_for_commits(self._args.upstream)
        alias_for = self._sha_aliases(summary_for)
        for hunk in hunks:
            self._blame(hunk, alias_for)
            self._fixup_hunk_by_sha(hunk, summary_for)
        pprint(hunks, width=200)
        pprint(summary_for, width=200)

        # pprint(alias_for)
        # pprint(hunks, width=200)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description=__doc__, formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument('-v', '--version', action='version',
                        version='%(prog)s ' + __version__)
    parser.add_argument("-U", "--unified", type=int, default=3,
                        help="Number of diff context lines (default: 3)")
    parser.add_argument("upstream",
                        help="Upstream commit. Hunks will be assigned to commits in range \"upstream..HEAD\"")
    args = parser.parse_args()

    gaf = GitAutoFixup(args)
    gaf.process()


'''
def blame(hunk, alias_for):
    # Check if the hunk count is 0, if so, return an empty dictionary
    if hunk['count'] == 0:
        return {}

    # Call the 'git blame' command with the necessary arguments
    cmd = ['git', 'blame', '--porcelain', f'-L {hunk["start"]},+{hunk["count"]}', 'HEAD', '--', hunk['file']]

    # Initialize an empty dictionary to store the blame information
    blame = {}

    # Open a subprocess to execute the 'git blame' command and read its output
    with subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as proc:
        # Loop through each line of the 'git blame' output
        for line in proc.stdout:
            # Convert the byte string to a UTF-8 string
            line = line.decode('utf-8').rstrip()

            # Parse the SHA and line number from the current line if possible
            match = re.match(r'^([0-9a-f]{40}) \d+ (\d+)', line)
            if match:
                sha, line_num = match.groups()

            # If the line starts with a tab character, add the blame information to the dictionary
            if line.startswith('\t'):
                if sha in alias_for:
                    sha = alias_for[sha]
                blame[int(line_num)] = {'sha': sha, 'text': line[1:]}

    # Check if the 'git blame' command completed successfully
    if proc.returncode != 0:
        raise subprocess.CalledProcessError(proc.returncode, cmd, stderr=proc.stderr.read())

    # Return the dictionary of blame information
    return blame

    
def fixup_sha(args):
    """
    Given a dictionary `args` containing the arguments `hunk`, `blame`,
    `summary_for`, and `strict`, this function determines the targets of a diff
    hunk that modifies lines that have been "blamed" to a certain commit in a
    Git repository. It calls either `fixup_targets_from_all_context` or
    `fixup_targets_from_adjacent_context` depending on the value of `strict`.
    It then checks if the upstream commit (i.e., the commit that originally
    "blamed" the modified lines) is among the targets. If it is and `strict` is
    `True`, the function returns `None`. If there are multiple targets, the
    function also returns `None`. If there is exactly one target, it returns
    that target. The function raises a `ValueError` if any of the arguments
    are `None`. The function also prints some diagnostic messages to the
    console if the `VERBOSE` flag is `True`, but this flag is not defined in
    the code snippet.
    """
    hunk = args['hunk']
    blame = args['blame']
    summary_for = args['summary_for']
    strict = args['strict']

    if None in (hunk, blame, summary_for, strict):
        raise ValueError('missing argument')

    targets = []
    if args['strict'] == CONTEXT:
        targets = fixup_targets_from_all_context(args)
        topic_targets = [t for t in targets if summary_for.get(t) is not None]
        if len(topic_targets) > 1:
            # The context assignment is ambiguous, but an adjacency assignment
            # might not be.
            targets = fixup_targets_from_adjacent_context(args)
    else:
        targets = fixup_targets_from_adjacent_context(args)

    upstream_is_blamed = any(summary_for.get(t) is None for t in targets)
    topic_targets = [t for t in targets if summary_for.get(t) is not None]
    if strict and upstream_is_blamed:
        VERBOSE and print(
            hunk_desc(hunk), " changes lines blamed on upstream\n")
        return None
    elif len(topic_targets) > 1:
        VERBOSE and print(hunk_desc(hunk), " has multiple targets\n")
        return None
    elif len(topic_targets) == 0:
        VERBOSE and print(hunk_desc(hunk), " has no targets\n")
        return None
    return topic_targets[0]


def hunk_desc(hunk):
    """
    Given a dictionary `hunk` containing information about a diff hunk in a Git
    repository (including the file path and the header), returns a string
    describing the hunk in a compact format. The string consists of the file
    path and the first @@-delimited segment of the header (which specifies the
    start and length of the modified lines). The two parts are separated by a
    space character.
    """
    return " ".join([hunk["file"], re.search("@@[^@]*@@", hunk["header"]).group()])


def fixup_targets_from_all_context(args):
    """
    Given a dictionary `args` containing the arguments `hunk`, `blame`, and
    `summary_for`, this function returns a list of Git commit hashes corresponding
    to the commits that "blamed" the modified lines in the hunk, based on the
    blame information in the `blame` dictionary. The `summary_for` dictionary maps
    Git commit hashes to "topics" (strings that describe the purpose or contents
    of the commit), and is used to filter the returned targets to only those
    with a known topic. If any of the required arguments are `None`, the function
    raises a `ValueError`.
    """
    hunk, blame, summary_for = args["hunk"], args["blame"], args["summary_for"]
    if any(v is None for v in (hunk, blame, summary_for)):
        raise ValueError("Missing argument")

    targets = list(set(b["sha"] for b in blame.values()))
    targets = [t for t in targets if summary_for.get(t)]
    return targets


def fixup_targets_from_adjacent_context(args):
        """
    Given a dictionary containing 'hunk', 'blame', 'summary_for', and 'strict' keys,
    this function returns a list of target commit hashes that are candidates for fixing
    the blame information for the lines changed in the 'hunk'.

    Args:
    - args: A dictionary containing the following keys:
        - 'hunk': A dictionary containing the file path, header, and diff lines of a hunk
        - 'blame': A dictionary containing blame information for the file
        - 'summary_for': A dictionary mapping topic names to commit hashes
        - 'strict': A flag indicating how strict to be when identifying targets

    Returns:
    - A list of commit hashes that are candidates for fixing the blame information for
      the lines changed in the 'hunk'.
    """
    hunk = args['hunk']
    blame = args['blame']
    summary_for = args['summary_for']
    strict = args['strict']
    
    if None in (hunk, blame, summary_for, strict):
        raise ValueError('missing argument')
    
    blame_indexes = blame_indexes(hunk)
    blamed = {}
    diff = hunk['lines']
    
    for di in range(len(diff)):
        bi = blame_indexes[di]
        line = diff[di]
        
        if line.startswith('-'):
            sha = blame[bi]['sha']
            blamed[sha] = 1
        elif line.startswith('+'):
            lines = []
            if di > 0 and blame.get(bi-1) is not None:
                lines.append(bi-1)
            
            if blame.get(bi) is not None:
                lines.append(bi)
            
            adjacent_shas = set([blame[x]['sha'] for x in lines])
            target_shas = [x for x in adjacent_shas if summary_for.get(x)]
            
            is_surrounded = len(target_shas) > 0 and len(target_shas) == len(adjacent_shas) and target_shas[0] == target_shas[-1]
            is_adjacent = len(target_shas) == 1
            
            if is_surrounded or (strict < SURROUNDED and is_adjacent):
                blamed[target_shas[0]] = 1
            
            while di < len(diff)-1 and diff[di+1].startswith('+'):
                di += 1
    
    targets = list(blamed.keys())
    return targets if strict else targets[0] if len(targets) == 1 else None


# Map lines in a hunk's diff to the corresponding `git blame HEAD` output.
def blame_indexes(hunk):
    indexes = []
    bi = hunk['start']
    for di in range(len(hunk['lines'])):
        indexes.append(bi)
        first = hunk['lines'][di][0]
        if first == '-' or first == ' ':
            bi += 1
        # Don't increment bi for added lines.
    return indexes

'''
